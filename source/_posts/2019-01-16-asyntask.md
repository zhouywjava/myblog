---
title: 原创:异步任务的设计
date: 2019-01-16 16:37:05
tags: 
- framework
- 异步
comments: true
categories: 
- Java架构
- 源码
- 任务
---



### RunnableFuture<V>

{% codeblock 认识:RunnableFuture<V> lang:java %}
package java.util.concurrent;

/**
 * A {@link Future} that is {@link Runnable}. Successful execution of
 * the <tt>run</tt> method causes completion of the <tt>Future</tt>
 * and allows access to its results.
 * @see FutureTask
 * @see Executor
 * @since 1.6
 * @author Doug Lea
 * @param <V> The result type returned by this Future's <tt>get</tt> method
 */
public interface RunnableFuture<V> extends Runnable, Future<V> {
    /**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}

{% endcodeblock %}

很简单的一个接口，是属于java.util.concurrent 包里的接口。它的描述很有意思。A Future that is Runnable。
可以知道这个接口是一个异步，任务扩展点。

### FutureTask<V>

那么这个接口是否有其默认的实现类呢？答案是肯定的。java.util.concurrent 包里 的 FutureTask 类

{% codeblock 认识:FutureTask<V> lang:java %}
/**
 * A cancellable asynchronous computation.  This class provides a base
 * implementation of {@link Future}, with methods to start and cancel
 * a computation, query to see if the computation is complete, and
 * retrieve the result of the computation.  The result can only be
 * retrieved when the computation has completed; the {@code get}
 * methods will block if the computation has not yet completed.  Once
 * the computation has completed, the computation cannot be restarted
 * or cancelled (unless the computation is invoked using
 * {@link #runAndReset}).
 *
 * <p>A {@code FutureTask} can be used to wrap a {@link Callable} or
 * {@link Runnable} object.  Because {@code FutureTask} implements
 * {@code Runnable}, a {@code FutureTask} can be submitted to an
 * {@link Executor} for execution.
 *
 * <p>In addition to serving as a standalone class, this class provides
 * {@code protected} functionality that may be useful when creating
 * customized task classes.
 *
 * @since 1.5
 * @author Doug Lea
 * @param <V> The result type returned by this FutureTask's {@code get} methods
 */
public class FutureTask<V> implements RunnableFuture<V> {
...
}
{% endcodeblock %}

FutureTask 就是一种组合模式